package be.vinci.pae.services;

import be.vinci.pae.utils.Config;
import be.vinci.pae.utils.exceptions.DALException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import org.apache.commons.dbcp2.BasicDataSource;

/**
 * DALServicesImpl class that implements DALServices interface Provide the different methods.
 */
public class DALServicesImpl implements DALServices, DalBackendServices {

  private final ThreadLocal<Connection> connectionThreadLocal
      = new ThreadLocal<Connection>();

  private final ThreadLocal<Integer> integerThreadLocalVerification = new ThreadLocal<>();
  /**
   * Connection to the database.
   */
  private final BasicDataSource bds;


  /**
   * DALServices constructor : Set the connection to the db.
   */
  public DALServicesImpl() {
    bds = new BasicDataSource();
    bds.setUrl(Config.getProperty("DatabaseUrl"));
    bds.setUsername(Config.getProperty("DatabaseUser"));
    bds.setPassword(Config.getProperty("DatabasePassword"));
    bds.setDriverClassName("org.postgresql.Driver");
    bds.setMaxTotal(1);
  }

  /**
   * Return the PreparedStatement associated at the request.
   *
   * @param request           the sql request
   * @param autoGeneratedKeys whether auto generated keys should be returned
   * @return the PreparedStatement of this sql request
   */
  @Override
  public PreparedStatement getPreparedStatement(String request, boolean autoGeneratedKeys) {
    try {
      return connectionThreadLocal.get().prepareStatement(request, autoGeneratedKeys
          ? Statement.RETURN_GENERATED_KEYS
          : Statement.NO_GENERATED_KEYS);
    } catch (SQLException e) {
      throw new DALException("Error during the creation of the PreparedStatement", e);
    }
  }

  /**
   * Return the PreparedStatement associated at the request, without the auto generated keys.
   *
   * @param request the sql request
   * @return the PreparedStatement of this sql request
   */
  @Override
  public PreparedStatement getPreparedStatement(String request) {
    return getPreparedStatement(request, false);
  }

  /**
   * Starts a transaction by getting a connection from the connection pool.
   */
  @Override
  //@Transactional(isolation = Isolation.SERIALIZABLE)
  //synchronized
  public void startTransaction() {

    if (integerThreadLocalVerification.get() == null) {

      try {
        integerThreadLocalVerification.set(1);
        Connection connection = bds.getConnection();
        connection.setAutoCommit(false);
        connectionThreadLocal.set(connection);
      } catch (SQLException e) {
        throw new DALException("Error during the creation of the transaction", e);
      }
    } else {
      integerThreadLocalVerification.set(integerThreadLocalVerification.get() + 1);
    }
  }

  /**
   * Commits the transaction by retrieving the connection from the ThreadLocal variable.
   */
  @Override
  public void commitTransaction() {

    if (integerThreadLocalVerification.get() == 1) {

      integerThreadLocalVerification.remove();

      Connection connection = connectionThreadLocal.get();
      try {
        connection.setAutoCommit(false);
        connection.commit();
        connectionThreadLocal.remove();
        connection.close();
      } catch (SQLException e) {
        throw new DALException("Error during the commit of the transaction", e);
      }
    } else {
      integerThreadLocalVerification.set(integerThreadLocalVerification.get() - 1);
    }
  }

  /**
   * Rolls back the transaction by retrieving the connection from the ThreadLocal variable.
   */
  @Override
  public void rollbackTransaction() {
    Connection connection = connectionThreadLocal.get();
    try {
      connection.rollback();
      connection.setAutoCommit(false);
    } catch (SQLException e) {
      throw new DALException("Error during the rollback of the transaction", e);
    }

  }
}
