package be.vinci.pae.services;

import be.vinci.pae.utils.Config;
import be.vinci.pae.utils.MyLogger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import org.apache.commons.dbcp2.BasicDataSource;

/**
 * DALServicesImpl class that implements DALServices interface Provide the different methods.
 */
public class DALServicesImpl implements DALServices, DalBackendServices {

  /**
   * Connection to the database.
   */
  private static final BasicDataSource bds;
  private static final ThreadLocal<Connection> connectionThreadLocal
      = new ThreadLocal<Connection>();

  static {
    bds = new BasicDataSource();
    //Setup of property
    bds.setUrl(Config.getProperty("DatabaseUrl"));
    bds.setUsername(Config.getProperty("DatabaseUser"));
    bds.setPassword(Config.getProperty("DatabasePassword"));
    bds.setDriverClassName("org.postgresql.Driver");
  }

  /**
   * Return the PreparedStatement associated at the request.
   *
   * @param request           the sql request
   * @param autoGeneratedKeys whether auto generated keys should be returned
   * @return the PreparedStatement of this sql request
   */
  @Override
  public PreparedStatement getPreparedStatement(String request, boolean autoGeneratedKeys) {
    try {
      return connectionThreadLocal.get().prepareStatement(request, autoGeneratedKeys
          ? Statement.RETURN_GENERATED_KEYS
          : Statement.NO_GENERATED_KEYS);
    } catch (SQLException se) {
      MyLogger.log(Level.INFO, "Get PS error");
      se.printStackTrace();
    }

    return null;
  }

  /**
   * Return the PreparedStatement associated at the request, without the auto generated keys.
   *
   * @param request the sql request
   * @return the PreparedStatement of this sql request
   */
  @Override
  public PreparedStatement getPreparedStatement(String request) {
    return getPreparedStatement(request, false);
  }

  /**
   * Starts a transaction by getting a connection from the connection pool.
   */
  @Override
  public void startTransaction() {
    try {
      Connection connection = bds.getConnection();
      connection.setAutoCommit(false);
      connectionThreadLocal.set(connection);
    } catch (SQLException se) {
      MyLogger.log(Level.INFO, "Start transaction error");
      se.printStackTrace();
    }

  }

  /**
   * Commits the transaction by retrieving the connection from the ThreadLocal variable.
   */
  @Override
  public void commitTransaction() {

    Connection connection = connectionThreadLocal.get();
    try {
      connection.setAutoCommit(false);
      connection.commit();
      connectionThreadLocal.remove();
      connection.close();
    } catch (SQLException e) {
      MyLogger.log(Level.INFO, "Commit transaction error");
      throw new RuntimeException(e);
    }

  }

  /**
   * Rolls back the transaction by retrieving the connection from the ThreadLocal variable.
   */
  @Override
  public void rollbackTransaction() {
    Connection connection = connectionThreadLocal.get();
    try {
      connection.rollback();
      connection.setAutoCommit(false);
    } catch (SQLException e) {
      MyLogger.log(Level.INFO, "Rollback transaction error");
      throw new RuntimeException(e);
    }

  }
}
